---
alwaysApply: true
---

# Nuxt 3 & TypeScript Development Standards

This document defines the architectural and coding standards for this project. Adherence ensures consistency, performance (Web Vitals), and long-term maintainability.

---

# Nuxt 3 & TypeScript Development Standards

This document defines the architectural and coding standards for this project. Adherence ensures consistency, performance (**Web Vitals**), and long-term maintainability.

## Purpose and Scope

These standards define the default way code is written, structured, and evolved. They exist to reduce **cognitive load**, prevent accidental complexity, and make the system understandable to both humans and AI agents.

- **Established patterns** must be followed. Deviations require team agreement.
- **Continuous learning** and refactoring are core expectations.
- **No rule is absolute**; this is the baseline for the majority of scenarios.

## General Principles

- **Boy Scout Rule:** Leave the codebase in a better state than you found it.
- **Readability Over Cleverness:** Optimize for the developer who has to fix your code at 3 AM.
- **Type Safety:** Leverage TypeScript to make "illegal states" unrepresentable.
- **Explicit > Implicit:** Prefer clear, verbose logic over "magic" behavior.

## Modern JavaScript & Logic Patterns

### Destructuring and Intent

Use destructuring to make your data usage explicit at the top of functions or component scripts.

**Bad**

```typescript
function printUser(user) {
  console.log(user.firstName);
  console.log(user.lastName);
}
```

**Good**

```typescript
function printUser({ firstName, lastName }: User) {
  console.log(firstName, lastName);
}
```

### Optional Chaining and Nullish Coalescing

Avoid deep if checks for nested properties.

**Bad**

```typescript
const name = user && user.profile && user.profile.name ? user.profile.name : 'Guest';
```

**Good**

```typescript
const name = user?.profile?.name ?? 'Guest';
```

### Async/Await and Error Handling

Always handle potential failures in asynchronous operations using try/catch or Nuxt’s built-in error handling.

**Bad**

```typescript
const data = await $fetch('/api/data'); // No error handling
```

**Good**

```typescript
try {
  const data = await $fetch('/api/data');
} catch (error) {
  console.error('Fetch failed:', error);
  // Handle specific UI feedback or error state
}
```

## Functions and Components

### Single Responsibility

Functions and components must have a single, clear purpose.

**Bad**

```typescript
function submitOrder(order) {
  saveOrder(order);
  sendConfirmation(order);
  trackMetric("order_submitted");
}
```

**Good**

```typescript
function submitOrder(order) {
  return saveOrder(order);
}
function onOrderSubmitted(order) {
  sendConfirmation(order);
  trackMetric("order_submitted");
}
```

### Control Flow

Prefer **early returns** and **guard clauses** to reduce nesting and mental overhead.

**Good**

```typescript
function process(order) {
  if (!order?.items?.length) return;
  if (!order.isPaid) return;
  shipOrder(order);
}
```

## State Management (Pinia Tips)

When using Pinia in a Nuxt 3 environment, follow these specific patterns to maintain reactivity and performance.

### 1\. Store Definition: Setup vs. Options

Prefer **Setup Stores** (using a function) as they feel more natural with Vue 3's Composition API and allow for more flexible logic.

```typescript
export const useUserStore = defineStore('user', () => {
  const user = ref(null);
  const isLoggedIn = computed(() => !!user.value);
  function logout() {
    user.value = null;
  }
  return { user, isLoggedIn, logout };
});
```

### 2\. Preserving Reactivity

Never destructure a Pinia store directly, as it breaks reactivity for state and getters. Use storeToRefs.

**Bad**

```typescript
const { user } = useUserStore(); // user is no longer reactive
```

**Good**

```typescript
const store = useUserStore();
const { user } = storeToRefs(store); // user remains a reactive Ref
```

### 3\. State as a Source of Truth

Do not sync store state with local refs inside components unless you are creating a "draft" for a form.

## Frontend Architecture (Nuxt 3)

### Layered Responsibility

1.  **Pages:** Routing, SEO metadata, and high-level composition.
2.  **Components:** Rendering logic and user interaction only.
3.  **Composables:** Reusable stateful logic (the "glue"). Use these for shared logic like useAuth or useForm.
4.  **Services/Utils:** Stateless helper functions or API wrappers.
5.  **Stores:** Global application state.

### URL-Driven State

Drive filters, pagination, and selections from the **URL** (query parameters) when possible. A page refresh must restore the same state; URLs should be meaningful and shareable.

## Naming Conventions

**CategoryConventionExampleVariables & Functions**camelCasefetchActiveSubscriptions**Types & Components**PascalCaseUserAccount**Constants**UPPERCASEMAX_RETRIES**Boolean Flags**Prefix with is, has, shouldisLoaded, hasError

## Testing

- **Isolation:** Each unit test must run in isolation.
- **Independence:** Tests must not depend on execution order.
- **Behavioral Focus:** Test what the user sees/does, not how the code is structured internally.
